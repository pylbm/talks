import numpy as np
import bokeh
from bokeh.models import FuncTickFormatter
from bokeh.io import push_notebook, show, output_notebook
from bokeh.plotting import figure
from bokeh.resources import INLINE, CDN

LaTeX = False

modify_exposant = """
var str = Math.log10(tick).toString(); //get exponent
var newStr = "";
for (var i=0; i<str.length;i++)
{
    var code = str.charCodeAt(i);
    switch(code) {
        case 45: // "-"
            newStr += "⁻";
            break;
        case 49: // "1"
            newStr +="¹";
            break;
        case 50: // "2"
            newStr +="²";
            break;
        case 51: // "3"
            newStr +="³"
            break;
        default: // all digit superscripts except 1, 2, and 3 can be generated by adding 8256
            newStr += String.fromCharCode(code+8256)
    }
}
return 10+newStr;
"""

class Fig():
    """
    Class Fig using bokeh module

    Parameters
    ----------

    x_range : a tuple for min and max value of the x coordinate
    y_range : a tuple for min and max value of the y coordinate
    width : integer, optional (default value is 450)
    height : integer, optional (default value is 300)

    """
    def __init__(self, x_range = (0,0), y_range = None,
                 width=450,
                 height=300,
                 x_label=None, y_label=None,
                 x_axis_type='auto', y_axis_type='auto'
                 ):

        output_notebook(resources = INLINE, hide_banner=True)
        self.fig = figure(x_range=x_range,
                          y_range=y_range,
                          width=width,
                          height=height,
                          x_axis_type=x_axis_type,
                          y_axis_type=y_axis_type)

        if x_label is not None:
            self.fig.xaxis.axis_label = x_label
        if y_label is not None:
            self.fig.yaxis.axis_label = y_label
        self.fig.xaxis.visible = True
        self.fig.yaxis.visible = True
        self.fig.xgrid.visible = False
        self.fig.ygrid.visible = False
        if x_axis_type == 'log':
            self.fig.xaxis[0].formatter = FuncTickFormatter(code=modify_exposant)
        if y_axis_type == 'log':
            self.fig.yaxis[0].formatter = FuncTickFormatter(code=modify_exposant)

    def title(self, title_str, title_color = None, title_align = None, title_size = None):
        """
        Set the title of the figure

        Parameters
        ----------

        title_str : string that contains the title
        title_color : string, optional
        title_align : string, optional

        """
        self.fig.title.text = title_str
        if title_color is not None:
            self.fig.title.text_color = title_color
        if title_align is not None:
            self.fig.title.align = title_align

    def legend(self, location = None, orientation = None, click_policy = None):
        if location is not None:
            self.fig.legend.location = location.replace('upper', 'top').replace('lower', 'bottom').replace(' ', '_')
        if orientation is not None:
            self.fig.legend.orientation = orientation
        if click_policy is not None:
            try:
                self.fig.legend.click_policy = click_policy
            except:
                print("Update bokeh to have interactive legend")

    def line(self, x, y, line_width = 2, line_color = 'black', line_alpha = 1, line_marker = None, label = None):
        """
        plot a line

        Parameters
        ----------

        x : numpy array of the x coordinate
        y : numpy array of the y coordinate
        line_width : integer, optional
        line_alpha : float between 0 and 1, optional
        line_marker : marker
        line_color : string, optional
        label : string, optional

        """
        return line(self.fig, x, y, line_width, line_color, line_alpha, line_marker, label)

    def scatter(self, x, y, marker = 'circle_x', size = 10, color = 'black', alpha = 0.5, label = None):
        """
        plot scatters

        Parameters
        ----------

        x : numpy array of the x coordinate
        y : numpy array of the y coordinate
        marker : string, optional
        size : integer, optional
        line_width : integer, optional
        color : string, optional

        """
        return scatter(self.fig, x, y, marker, size, color, alpha, label)

    def fill(self, x, y1, y2 = None, line_width = 1, line_color = 'black', fill_color = 'black', fill_alpha = 0.25):
        """
        fill the region between y1 and y2

        Parameters
        ----------

        x : numpy array of the x coordinate
        y1 : numpy array of the first y coordinate
        y2 : numpy array of the second y coordinate, optional (default is 0.)
        fill_color : string, optional
        fill_alpha : float, optional
        line_width : float, optional
        line_color : string, optional

        """
        return fill(self.fig, x, y1, y2, fill_color, fill_alpha, line_width, line_color)

    def plot(self):
        self.handle = show(self.fig, notebook_handle=True)

    def update(self):
        notebook_handle=True
        push_notebook(handle = self.handle)

    def savefig(self, filename):
        print("The viewer Bokeh cannot save the figure")


class line():
    """
    line object
    """
    def __init__(self, fig, x, y, lw, c, alpha, m, label):
        if isinstance(c, tuple):
            c = tuple([int(a*255) for a in c])
        self.l = fig.line(x, y, line_width = lw, color = c, line_alpha = alpha, legend = label)
        self.l.visible = True
        if m is not None:
            self.marker = True
            self.m = fig.scatter(x, y,
                                 marker = m,
                                 size = 5,
                                 fill_color = c,
                                 line_color = c,
                                 alpha = alpha,
                                 legend = label)
            self.m.visible = True
        else:
            self.marker = False
    def visible(self, b = True):
        self.l.visible = b
        if self.marker:
            self.m.visible = b
    def update(self, x, y):
        self.l.data_source.data = dict(x = x, y = y)
        if self.marker:
            self.m.data_source.data = dict(x = x, y = y)
    def line_color(self, c):
        if isinstance(c, tuple):
            c = tuple([int(a*255) for a in c])
        self.l.glyph.line_color = c
        if self.marker:
            self.m.glyph.line_color = c
            self.m.glyph.fill_color = c


class scatter():
    """
    scatter object
    """
    def __init__(self, fig, x, y, m, s, c, alpha, label):
        if isinstance(c, tuple):
            c = tuple([int(a*255) for a in c])
        self.l = fig.scatter(x, y,
                             marker = m,
                             size = s,
                             line_color = 'black',
                             fill_color = c,
                             alpha = alpha,
                             legend = label)
        self.l.visible = True
    def visible(self, b = True):
        self.l.visible = b
    def update(self, x, y):
        self.l.data_source.data = dict(x = x, y = y)
    def line_color(self, c):
        if isinstance(c, tuple):
            c = tuple([int(a*255) for a in c])
        self.l.glyph.line_color = c
    def fill_color(self, c):
        if isinstance(c, tuple):
            c = tuple([int(a*255) for a in c])
        self.l.glyph.fill_color = c

class fill():
    """
    fill object

    Warning: cannot manage set_offsets (the collection is removed and then recreated each time)
    """
    def __init__(self, fig, x, y1, y2, fc, fa, lw, lc):
        if y2 is None:
            xx = np.zeros((x.size + 2,))
            xx[:-2] = x
            xx[-2] = x[-1]
            xx[-1] = x[0]
            yy = np.zeros((y1.size + 2))
            yy[:-2] = y1
        else:
            xx = np.append(x, x[::-1])
            yy = np.append(y1, y2[::-1])
        self.l = fig.patch(xx, yy, alpha=fa, line_width=lw, color = fc)
        self.l.visible = True
    def visible(self, b = True):
        self.l.visible = b
    def update(self, x, y1, y2 = None):
        if y2 is None:
            xx = np.zeros((x.size + 2,))
            xx[:-2] = x
            xx[-2] = x[-1]
            xx[-1] = x[0]
            yy = np.zeros((y1.size + 2))
            yy[:-2] = y1
        else:
            xx = np.append(x, x[::-1])
            yy = np.append(y1, y2[::-1])
        self.l.data_source.data = dict(x = xx, y = yy)
